-------------------------------------------------- FLOATING POINT ADDITION 

1. Add the following decimal numbers using 32-bit floating point representation:
   a)	12.375 + 3.625,
   b)   1.5 × 2^5  +  1.25 × 2^2
   c)   -6.5 + (-2.25),   
   d)	9.125 + (-4.75), 
   e)	1.1011 × 2^3  +  1.0110 × 2^1

2. Perform floating point addition and show rounding:
   0.1 + 0.2
   Explain why the result is not exactly 0.3 in binary floating point.

3. Add two very small numbers and observe underflow behavior:
   1.0 × 2^-126  +  1.0 × 2^-126

4. Show that floating point addition is not associative (i.e., (a+b)+c != a+(b+c) ) from the following example 
   - 1.0 × 2^-126  +  1.0 × 2^-126 + 1


5. Add these and give the result, assuming you can only store 5 bits + 1 guard bit.
    1.0000001 × 2^0  +  1.0000000 × 2^-7

----------------------------------- Floating point multiplication

6. Multiply the following decimal numbers:
	a) 3.5 x 2.25
	b) 6.0 x 0.75
	c) -4.5 x (-1.5)
	d) -2.75 x 3.0
	e) (1.101)_2 x 2^2   x   (1.011)_2 x 2^1


7. Multiply and show rounding effects:
   0.1 × 0.2
   Explain why the result is not exact in binary floating point.


8. Multiply:    0.0 × 15.75
    Explain the result.

9. Multiply:    Infinity × 0.0
    State the IEEE 754 result and reason.

10. Multiply:    NaN × 5.0
    Explain why the result is NaN.

-------------------------------------------------- ASCII ENCODING AND DECODING 

11. Write a c code to print unsigned integer values of the following characters into ASCII
   a) A
   b) z
   c) 0
   d) @
   e) newline

12. Write a c code to Decode the following 7-bit ASCII binary values into characters:
   a) 1000001
   b) 1100001
   c) 0110000
   d) 0100000
   e) 0001010

13. Write a c code to Encode the following string into ASCII binary print their HEX: 
   "HELLO"

14. Decode the following ASCII hexadecimal sequence into text:
   48 65 6C 6C 6F


15. Write a c code to find the difference (in decimal) in their ASCII value between:
   a) 'A' and 'a'
   b) '0' and '9'
   c) 'A' and 'D'
   You are not allowed to take more than two variables


-------------------------------------------------- BITWISE AND LOGICAL OPERATORS
Instructions:
- Represent all numbers in 8-bit binary.
- For logical operators, non-zero is true (1) and zero is false (0).

16. Find Results in the following operations Bitwise logical operations:
   a) 00110101 AND 00011100
   b) 01011010 OR 00101101
   c) 01101001 XOR 00111100
   d) NOT 01010110 (In C, the bitwise NOT operator ~ inverts each bit. )
   
Note that in C, the bitwise AND, OR, XOR, and NOT operators are written as &, |, ^, and ~ respectively.


17. Shift operations:
   a) 00101101 << 2
   b) 10110010 >> 3   (logical right shift)
   
Note that when a variable is defined as signed, a right shift preserves the sign bit by keeping 1 in the MSB. However, the same operation inserts 0 in the MSB when the variable is unsigned.


18. Bitwise operations using decimal values:
   a) 45 AND 29
   b) 72 OR 15

19. Logical AND operations:
   a) 0 AND 7
   b) 3 AND 5

20. Logical OR and NOT operations:
   a) 0 OR 0
   b) NOT 12

--------------------------------------------------

These problems should be solved by this weekends

End of Homework


